# README

Данный проект содержит собственную реализацию ассоциативного контейнера `map`, аналогичного `std::map` из стандартной библиотеки C++. Основой структуры данных является красно-чёрное дерево (`RedBlackTree`), реализованное в файле `red-black-tree.hpp`. Контейнер `map` определён в файле `map.hpp` и использует красно-чёрное дерево для хранения ключ-значение пар.

## Содержание

1. [Общая информация](#общая-информация)
2. [Структура репозитория](#структура-репозитория)
3. [Сборка и запуск](#сборка-и-запуск)
4. [Описание классов](#описание-классов)
   - [RedBlackTree](#класс-redblacktree)
   - [map](#класс-map)
5. [Пример использования](#пример-использования)
6. [Особенности](#особенности)
7. [Лицензия](#лицензия)

---

## Общая информация

Контейнер `mystl::map` из этого проекта реализует сбалансированное дерево поиска, где в качестве узлов хранятся пары вида `(Key, T)`. Ключевые особенности:
- Гарантированная асимптотика операций поиска, вставки и удаления `O(log N)`.
- Поддержка итераторов: прямые и обратные (bidirectional iterators).
- Методы, совместимые с интерфейсом `std::map` (например, `insert`, `erase`, `find`, `lower_bound`, `upper_bound` и т.д.).
- Поддержка большинства современных методов `map` (включая `emplace`, `try_emplace`, `merge` и др.).

---

## Структура репозитория

- **`red-black-tree.hpp`**  
  Реализация красно-чёрного дерева `RedBlackTree`, на котором базируется `map`.
  
- **`map.hpp`**  
  Реализация контейнера `mystl::map`, использующего `RedBlackTree` как внутреннюю структуру данных.
  
- **`test.cpp`**  
  Пример использования контейнера `mystl::map` (тестовый файл, в котором демонстрируется функционал и методы класса).

---

## Сборка и запуск

1. Склонируйте репозиторий или скачайте исходный код.
2. Соберите проект любым удобным способом, например, используя компилятор `g++`:

   ```bash
   g++ -std=c++20 O3 test.cpp -o test
   clang++ -std=c++20 O3 test.cpp -o test
   ```
   
   Здесь:
   - `-std=c++17` указывает использование стандарта C++17 (можно использовать и более высокий стандарт, если требуется).
   - `test.cpp` – файл с `main`-функцией, демонстрирующий работу.
   - `-o test` – имя выходного исполняемого файла.
   
3. Запустите скомпилированную программу:

   ```bash
   ./test
   ```

Вы увидите вывод, демонстрирующий различные операции над `map`.

---

## Описание классов

### Класс `RedBlackTree`

Расположен в файле [`red-black-tree.hpp`](./red-black-tree.hpp).  
Основные методы:
- **`find(const K& key)`** – Поиск узла с ключом `key`.
- **`insertNode(const std::pair<const Key, T>& val)`** – Вставка нового узла.
- **`removeNode(const Key& key)`** – Удаление узла с ключом `key`.
- **`clear()`** – Удаление всех узлов дерева.
- **`minNode()` и `maxNode()`** – Возвращают узел с минимальным или максимальным ключом.
- **`successor(Node* node)`** и `predecessor(Node* node)`** – Поиск следующего/предыдущего узла в порядке возрастания ключей.
- **`validate()`** – Проверка структуры дерева на соответствие свойствам красно-чёрного дерева (для отладки).

Все операции структурированы согласно классическим правилам красно-чёрного дерева:
- После вставки или удаления выполняется балансировка.
- Дерево хранит узлы с пометкой цвета (красный или чёрный).

### Класс `map`

Расположен в файле [`map.hpp`](./map.hpp).  
Основная задача – предоставить интерфейс, аналогичный `std::map`.

#### Шаблон класса

```cpp
template <typename Key, typename T,
          typename Compare = std::less<Key>,
          typename Allocator = std::allocator<std::pair<const Key, T>>>
class map;
```

- **Key** – тип ключей.
- **T** – тип значений, ассоциированных с ключом.
- **Compare** – функтор сравнения (по умолчанию `std::less<Key>`).
- **Allocator** – аллокатор памяти для хранения пар `(Key, T)`.

#### Основные методы

- **Итераторы**: `begin()`, `end()`, `rbegin()`, `rend()`, и их константные версии.
- **Доступ к элементам**:
  - `operator[](const key_type& key)`
  - `at(const key_type& key)`
- **Модификация**:
  - `insert(...)`, `emplace(...)`
  - `erase(...)`, `clear()`
  - `merge(...)`
- **Поиск**: `find(...)`, `count(...)`, `contains(...)`
- **Границы**: `lower_bound(...)`, `upper_bound(...)`, `equal_range(...)`
- **Прочее**:  
  - `size()`, `empty()`, `max_size()`
  - `swap(...)`
  - Операторы сравнения: `==, !=, <, >, <=, >=`

#### Итераторы
Имеются два типа итераторов:
1. **`iterator`** – позволяет изменять значение `mapped_type` (второй компонент пары), но не ключ.
2. **`const_iterator`** – только чтение (как у стандартного `std::map`).

Итераторы двунаправленные (bidirectional).

---

## Пример использования

Ниже приведён фрагмент из [`test.cpp`](./test.cpp), иллюстрирующий базовые операции:

```cpp
#include <iostream>
#include "map.hpp"

int main() {
    mystl::map<int, std::string> m;

    // Вставка (insert, operator[])
    m[1] = "one";
    m.insert({2, "two"});
    m.insert(std::make_pair(3, "three"));

    // Обход и вывод
    std::cout << "Map contents:\n";
    for (const auto& [key, value] : m) {
        std::cout << "  [" << key << "] = " << value << '\n';
    }

    // Поиск и доступ по индексу
    auto it = m.find(2);
    if (it != m.end()) {
        std::cout << "Found key 2: " << it->second << '\n';
    }

    // Удаление
    m.erase(2);

    return 0;
}
```

Более детальные примеры использования можно найти непосредственно в файле [`test.cpp`](./test.cpp).

---

## Особенности

1. **Использование `unique_ptr`**  
   Для хранения дочерних узлов дерева используются `std::unique_ptr`, что упрощает управление памятью (RAII).
2. **Шаблонные методы поиска**  
   Благодаря проверки на `is_transparent`, можно осуществлять поиск по типам, отличным от `Key`, если `Compare` содержит прозрачный тип сравнения (например, `std::less<>`).
3. **EBO (Empty Base Optimization)**  
   Класс `map` хранит внутри себя компаратор и аллокатор через классы `EBO`, что в случае пустого компаратора/аллокатора позволяет оптимизировать использование памяти.
4. **Аналогия с C++17/C++20**  
   Реализованы методы, которые появились в более новых стандартах, такие как `merge`, `try_emplace` и др.

---

## Лицензия

Данный код предоставляется "как есть" в учебных/ознакомительных целях. Используйте по своему усмотрению. При копировании просьба указывать ссылку на оригинальный репозиторий/автора.  